// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: shop_order.sql

package db

import (
	"context"
	"time"

	null "github.com/guregu/null/v5"
)

const adminListShopOrdersNextPage = `-- name: AdminListShopOrdersNextPage :many
With t1 AS (
SELECT 1 AS is_admin
    FROM "admin"
    WHERE "admin".id = $2
    AND active = TRUE
    ),
t2 AS (
SELECT os.status,
(
  SELECT COUNT(*) FROM "shop_order_item" AS soi
  WHERE soi.order_id = so.id
) AS item_count,
usr.username,
so.id, so.track_number, so.order_number, so.user_id, so.payment_type_id, so.shipping_address_id, so.order_total, so.shipping_method_id, so.order_status_id, so.address_name, so.address_telephone, so.address_line, so.address_region, so.address_city, so.created_at, so.updated_at, so.completed_at, COUNT(*) OVER() AS total_count
FROM "shop_order" AS so
LEFT JOIN "order_status" AS os ON os.id = so.order_status_id
LEFT JOIN "user" AS usr ON usr.id = so.user_id
WHERE so.id < $3
AND (SELECT is_admin FROM t1) = 1
AND CASE
WHEN COALESCE($4, '') != ''
THEN os.status = $4
    ELSE 1=1
END
ORDER BY so.id DESC
LIMIT $1 + 1
)
SELECT status, item_count, username, id, track_number, order_number, user_id, payment_type_id, shipping_address_id, order_total, shipping_method_id, order_status_id, address_name, address_telephone, address_line, address_region, address_city, created_at, updated_at, completed_at, total_count,COUNT(*) OVER()>10 AS next_available FROM t2
LIMIT $1
`

type AdminListShopOrdersNextPageParams struct {
	Limit       int32       `json:"limit"`
	AdminID     int64       `json:"admin_id"`
	ShopOrderID int64       `json:"shop_order_id"`
	OrderStatus interface{} `json:"order_status"`
}

type AdminListShopOrdersNextPageRow struct {
	Status            null.String `json:"status"`
	ItemCount         int64       `json:"item_count"`
	Username          null.String `json:"username"`
	ID                int64       `json:"id"`
	TrackNumber       string      `json:"track_number"`
	OrderNumber       int32       `json:"order_number"`
	UserID            int64       `json:"user_id"`
	PaymentTypeID     int64       `json:"payment_type_id"`
	ShippingAddressID null.Int    `json:"shipping_address_id"`
	OrderTotal        string      `json:"order_total"`
	ShippingMethodID  int64       `json:"shipping_method_id"`
	OrderStatusID     null.Int    `json:"order_status_id"`
	AddressName       string      `json:"address_name"`
	AddressTelephone  string      `json:"address_telephone"`
	AddressLine       string      `json:"address_line"`
	AddressRegion     string      `json:"address_region"`
	AddressCity       string      `json:"address_city"`
	CreatedAt         time.Time   `json:"created_at"`
	UpdatedAt         time.Time   `json:"updated_at"`
	CompletedAt       time.Time   `json:"completed_at"`
	TotalCount        int64       `json:"total_count"`
	NextAvailable     bool        `json:"next_available"`
}

func (q *Queries) AdminListShopOrdersNextPage(ctx context.Context, arg AdminListShopOrdersNextPageParams) ([]AdminListShopOrdersNextPageRow, error) {
	rows, err := q.db.Query(ctx, adminListShopOrdersNextPage,
		arg.Limit,
		arg.AdminID,
		arg.ShopOrderID,
		arg.OrderStatus,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminListShopOrdersNextPageRow{}
	for rows.Next() {
		var i AdminListShopOrdersNextPageRow
		if err := rows.Scan(
			&i.Status,
			&i.ItemCount,
			&i.Username,
			&i.ID,
			&i.TrackNumber,
			&i.OrderNumber,
			&i.UserID,
			&i.PaymentTypeID,
			&i.ShippingAddressID,
			&i.OrderTotal,
			&i.ShippingMethodID,
			&i.OrderStatusID,
			&i.AddressName,
			&i.AddressTelephone,
			&i.AddressLine,
			&i.AddressRegion,
			&i.AddressCity,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
			&i.TotalCount,
			&i.NextAvailable,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListShopOrdersV2 = `-- name: AdminListShopOrdersV2 :many
WITH t1 AS (
SELECT 1 AS is_admin
    FROM "admin"
    WHERE "admin".id = $2
    AND active = TRUE
    ),
t2 AS (
  SELECT os.status,(
  SELECT COUNT(*) FROM "shop_order_item" AS soi
  WHERE soi.order_id = so.id
) AS item_count,
usr.username,
so.id, so.track_number, so.order_number, so.user_id, so.payment_type_id, so.shipping_address_id, so.order_total, so.shipping_method_id, so.order_status_id, so.address_name, so.address_telephone, so.address_line, so.address_region, so.address_city, so.created_at, so.updated_at, so.completed_at, COUNT(*) OVER() AS total_count
FROM "shop_order" AS so
LEFT JOIN "order_status" AS os ON os.id = so.order_status_id
LEFT JOIN "user" AS usr ON usr.id = so.user_id
WHERE (SELECT is_admin FROM t1) = 1
AND CASE
WHEN COALESCE($3, '') != ''
THEN os.status = $3
    ELSE 1=1
END
ORDER BY so.id DESC
LIMIT $1 + 1
)

SELECT status, item_count, username, id, track_number, order_number, user_id, payment_type_id, shipping_address_id, order_total, shipping_method_id, order_status_id, address_name, address_telephone, address_line, address_region, address_city, created_at, updated_at, completed_at, total_count,COUNT(*) OVER()>10 AS next_available FROM t2 
LIMIT $1
`

type AdminListShopOrdersV2Params struct {
	Limit       int32       `json:"limit"`
	AdminID     int64       `json:"admin_id"`
	OrderStatus interface{} `json:"order_status"`
}

type AdminListShopOrdersV2Row struct {
	Status            null.String `json:"status"`
	ItemCount         int64       `json:"item_count"`
	Username          null.String `json:"username"`
	ID                int64       `json:"id"`
	TrackNumber       string      `json:"track_number"`
	OrderNumber       int32       `json:"order_number"`
	UserID            int64       `json:"user_id"`
	PaymentTypeID     int64       `json:"payment_type_id"`
	ShippingAddressID null.Int    `json:"shipping_address_id"`
	OrderTotal        string      `json:"order_total"`
	ShippingMethodID  int64       `json:"shipping_method_id"`
	OrderStatusID     null.Int    `json:"order_status_id"`
	AddressName       string      `json:"address_name"`
	AddressTelephone  string      `json:"address_telephone"`
	AddressLine       string      `json:"address_line"`
	AddressRegion     string      `json:"address_region"`
	AddressCity       string      `json:"address_city"`
	CreatedAt         time.Time   `json:"created_at"`
	UpdatedAt         time.Time   `json:"updated_at"`
	CompletedAt       time.Time   `json:"completed_at"`
	TotalCount        int64       `json:"total_count"`
	NextAvailable     bool        `json:"next_available"`
}

func (q *Queries) AdminListShopOrdersV2(ctx context.Context, arg AdminListShopOrdersV2Params) ([]AdminListShopOrdersV2Row, error) {
	rows, err := q.db.Query(ctx, adminListShopOrdersV2, arg.Limit, arg.AdminID, arg.OrderStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AdminListShopOrdersV2Row{}
	for rows.Next() {
		var i AdminListShopOrdersV2Row
		if err := rows.Scan(
			&i.Status,
			&i.ItemCount,
			&i.Username,
			&i.ID,
			&i.TrackNumber,
			&i.OrderNumber,
			&i.UserID,
			&i.PaymentTypeID,
			&i.ShippingAddressID,
			&i.OrderTotal,
			&i.ShippingMethodID,
			&i.OrderStatusID,
			&i.AddressName,
			&i.AddressTelephone,
			&i.AddressLine,
			&i.AddressRegion,
			&i.AddressCity,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
			&i.TotalCount,
			&i.NextAvailable,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createShopOrder = `-- name: CreateShopOrder :one
INSERT INTO "shop_order" (
  track_number,
  order_number,
  user_id,
  payment_type_id,
  shipping_address_id,
  order_total,
  shipping_method_id,
  order_status_id,
  address_name,
  address_telephone,
  address_line,
  address_region,
  address_city
) VALUES (
  $1, 
  (
    SELECT COUNT(*) FROM "shop_order" so
    WHERE so.user_id = $2
     ) + 1, 
    $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
)
RETURNING id, track_number, order_number, user_id, payment_type_id, shipping_address_id, order_total, shipping_method_id, order_status_id, address_name, address_telephone, address_line, address_region, address_city, created_at, updated_at, completed_at
`

type CreateShopOrderParams struct {
	TrackNumber       string   `json:"track_number"`
	UserID            int64    `json:"user_id"`
	PaymentTypeID     int64    `json:"payment_type_id"`
	ShippingAddressID null.Int `json:"shipping_address_id"`
	OrderTotal        string   `json:"order_total"`
	ShippingMethodID  int64    `json:"shipping_method_id"`
	OrderStatusID     null.Int `json:"order_status_id"`
	AddressName       string   `json:"address_name"`
	AddressTelephone  string   `json:"address_telephone"`
	AddressLine       string   `json:"address_line"`
	AddressRegion     string   `json:"address_region"`
	AddressCity       string   `json:"address_city"`
}

func (q *Queries) CreateShopOrder(ctx context.Context, arg CreateShopOrderParams) (ShopOrder, error) {
	row := q.db.QueryRow(ctx, createShopOrder,
		arg.TrackNumber,
		arg.UserID,
		arg.PaymentTypeID,
		arg.ShippingAddressID,
		arg.OrderTotal,
		arg.ShippingMethodID,
		arg.OrderStatusID,
		arg.AddressName,
		arg.AddressTelephone,
		arg.AddressLine,
		arg.AddressRegion,
		arg.AddressCity,
	)
	var i ShopOrder
	err := row.Scan(
		&i.ID,
		&i.TrackNumber,
		&i.OrderNumber,
		&i.UserID,
		&i.PaymentTypeID,
		&i.ShippingAddressID,
		&i.OrderTotal,
		&i.ShippingMethodID,
		&i.OrderStatusID,
		&i.AddressName,
		&i.AddressTelephone,
		&i.AddressLine,
		&i.AddressRegion,
		&i.AddressCity,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const deleteShopOrder = `-- name: DeleteShopOrder :exec
DELETE FROM "shop_order"
WHERE id = $1
`

func (q *Queries) DeleteShopOrder(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteShopOrder, id)
	return err
}

const getCompletedDailyOrderTotal = `-- name: GetCompletedDailyOrderTotal :one
With t1 AS (
SELECT 1 AS is_admin
    FROM "admin"
    WHERE "admin".id = $1
    AND active = TRUE
    )
SELECT
    COALESCE(SUM(CAST(order_total AS NUMERIC)),'0')::VARCHAR AS daily_revenue
FROM
    shop_order
WHERE order_status_id = 2
AND updated_at >= CURRENT_DATE
AND updated_at < CURRENT_DATE + INTERVAL '1 day'
AND EXISTS(SELECT is_admin FROM t1)
`

func (q *Queries) GetCompletedDailyOrderTotal(ctx context.Context, adminID int64) (string, error) {
	row := q.db.QueryRow(ctx, getCompletedDailyOrderTotal, adminID)
	var daily_revenue string
	err := row.Scan(&daily_revenue)
	return daily_revenue, err
}

const getShopOrder = `-- name: GetShopOrder :one
SELECT id, track_number, order_number, user_id, payment_type_id, shipping_address_id, order_total, shipping_method_id, order_status_id, address_name, address_telephone, address_line, address_region, address_city, created_at, updated_at, completed_at FROM "shop_order"
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetShopOrder(ctx context.Context, id int64) (ShopOrder, error) {
	row := q.db.QueryRow(ctx, getShopOrder, id)
	var i ShopOrder
	err := row.Scan(
		&i.ID,
		&i.TrackNumber,
		&i.OrderNumber,
		&i.UserID,
		&i.PaymentTypeID,
		&i.ShippingAddressID,
		&i.OrderTotal,
		&i.ShippingMethodID,
		&i.OrderStatusID,
		&i.AddressName,
		&i.AddressTelephone,
		&i.AddressLine,
		&i.AddressRegion,
		&i.AddressCity,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getShopOrdersCountByStatusId = `-- name: GetShopOrdersCountByStatusId :one
With t1 AS (
SELECT 1 AS is_admin
    FROM "admin"
    WHERE "admin".id = $2
    AND active = TRUE
    )
SELECT COUNT(*) AS orders_count FROM shop_order
WHERE order_status_id = $1
AND EXISTS(SELECT is_admin FROM t1)
`

type GetShopOrdersCountByStatusIdParams struct {
	OrderStatusID null.Int `json:"order_status_id"`
	AdminID       int64    `json:"admin_id"`
}

func (q *Queries) GetShopOrdersCountByStatusId(ctx context.Context, arg GetShopOrdersCountByStatusIdParams) (int64, error) {
	row := q.db.QueryRow(ctx, getShopOrdersCountByStatusId, arg.OrderStatusID, arg.AdminID)
	var orders_count int64
	err := row.Scan(&orders_count)
	return orders_count, err
}

const getTotalShopOrder = `-- name: GetTotalShopOrder :one
With t1 AS (
SELECT 1 AS is_admin
    FROM "admin"
    WHERE "admin".id = $1
    AND active = TRUE
    )
SELECT COUNT(*) AS orders_count FROM shop_order
WHERE EXISTS(SELECT is_admin FROM t1)
`

func (q *Queries) GetTotalShopOrder(ctx context.Context, adminID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalShopOrder, adminID)
	var orders_count int64
	err := row.Scan(&orders_count)
	return orders_count, err
}

const listShopOrders = `-- name: ListShopOrders :many
SELECT id, track_number, order_number, user_id, payment_type_id, shipping_address_id, order_total, shipping_method_id, order_status_id, address_name, address_telephone, address_line, address_region, address_city, created_at, updated_at, completed_at FROM "shop_order"
ORDER BY id
LIMIT $1
OFFSET $2
`

type ListShopOrdersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListShopOrders(ctx context.Context, arg ListShopOrdersParams) ([]ShopOrder, error) {
	rows, err := q.db.Query(ctx, listShopOrders, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ShopOrder{}
	for rows.Next() {
		var i ShopOrder
		if err := rows.Scan(
			&i.ID,
			&i.TrackNumber,
			&i.OrderNumber,
			&i.UserID,
			&i.PaymentTypeID,
			&i.ShippingAddressID,
			&i.OrderTotal,
			&i.ShippingMethodID,
			&i.OrderStatusID,
			&i.AddressName,
			&i.AddressTelephone,
			&i.AddressLine,
			&i.AddressRegion,
			&i.AddressCity,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShopOrdersByUserID = `-- name: ListShopOrdersByUserID :many
SELECT os.status,
ROW_NUMBER() OVER(ORDER BY so.id) as order_number,
(
  SELECT COUNT(*) FROM "shop_order_item" AS soi
  WHERE soi.order_id = so.id
) AS item_count,so.id, so.track_number, so.order_number, so.user_id, so.payment_type_id, so.shipping_address_id, so.order_total, so.shipping_method_id, so.order_status_id, so.address_name, so.address_telephone, so.address_line, so.address_region, so.address_city, so.created_at, so.updated_at, so.completed_at
FROM "shop_order" AS so
LEFT JOIN "order_status" AS os ON os.id = so.order_status_id
WHERE so.user_id = $1
ORDER BY so.id DESC
LIMIT $2
OFFSET $3
`

type ListShopOrdersByUserIDParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListShopOrdersByUserIDRow struct {
	Status            null.String `json:"status"`
	OrderNumber       int64       `json:"order_number"`
	ItemCount         int64       `json:"item_count"`
	ID                int64       `json:"id"`
	TrackNumber       string      `json:"track_number"`
	OrderNumber_2     int32       `json:"order_number_2"`
	UserID            int64       `json:"user_id"`
	PaymentTypeID     int64       `json:"payment_type_id"`
	ShippingAddressID null.Int    `json:"shipping_address_id"`
	OrderTotal        string      `json:"order_total"`
	ShippingMethodID  int64       `json:"shipping_method_id"`
	OrderStatusID     null.Int    `json:"order_status_id"`
	AddressName       string      `json:"address_name"`
	AddressTelephone  string      `json:"address_telephone"`
	AddressLine       string      `json:"address_line"`
	AddressRegion     string      `json:"address_region"`
	AddressCity       string      `json:"address_city"`
	CreatedAt         time.Time   `json:"created_at"`
	UpdatedAt         time.Time   `json:"updated_at"`
	CompletedAt       time.Time   `json:"completed_at"`
}

func (q *Queries) ListShopOrdersByUserID(ctx context.Context, arg ListShopOrdersByUserIDParams) ([]ListShopOrdersByUserIDRow, error) {
	rows, err := q.db.Query(ctx, listShopOrdersByUserID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListShopOrdersByUserIDRow{}
	for rows.Next() {
		var i ListShopOrdersByUserIDRow
		if err := rows.Scan(
			&i.Status,
			&i.OrderNumber,
			&i.ItemCount,
			&i.ID,
			&i.TrackNumber,
			&i.OrderNumber_2,
			&i.UserID,
			&i.PaymentTypeID,
			&i.ShippingAddressID,
			&i.OrderTotal,
			&i.ShippingMethodID,
			&i.OrderStatusID,
			&i.AddressName,
			&i.AddressTelephone,
			&i.AddressLine,
			&i.AddressRegion,
			&i.AddressCity,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShopOrdersByUserIDNextPage = `-- name: ListShopOrdersByUserIDNextPage :many
SELECT os.status,
(
  SELECT COUNT(*) FROM "shop_order_item" AS soi
  WHERE soi.order_id = so.id
) AS item_count
, so.id, so.track_number, so.order_number, so.user_id, so.payment_type_id, so.shipping_address_id, so.order_total, so.shipping_method_id, so.order_status_id, so.address_name, so.address_telephone, so.address_line, so.address_region, so.address_city, so.created_at, so.updated_at, so.completed_at, COUNT(*) OVER() AS total_count
FROM "shop_order" AS so
LEFT JOIN "order_status" AS os ON os.id = so.order_status_id
WHERE so.user_id = $2
AND so.id < $3
AND CASE
WHEN COALESCE($4, '') != ''
THEN os.status = $4
    ELSE 1=1
END
ORDER BY so.id DESC
LIMIT $1
`

type ListShopOrdersByUserIDNextPageParams struct {
	Limit       int32       `json:"limit"`
	UserID      int64       `json:"user_id"`
	ShopOrderID int64       `json:"shop_order_id"`
	OrderStatus interface{} `json:"order_status"`
}

type ListShopOrdersByUserIDNextPageRow struct {
	Status            null.String `json:"status"`
	ItemCount         int64       `json:"item_count"`
	ID                int64       `json:"id"`
	TrackNumber       string      `json:"track_number"`
	OrderNumber       int32       `json:"order_number"`
	UserID            int64       `json:"user_id"`
	PaymentTypeID     int64       `json:"payment_type_id"`
	ShippingAddressID null.Int    `json:"shipping_address_id"`
	OrderTotal        string      `json:"order_total"`
	ShippingMethodID  int64       `json:"shipping_method_id"`
	OrderStatusID     null.Int    `json:"order_status_id"`
	AddressName       string      `json:"address_name"`
	AddressTelephone  string      `json:"address_telephone"`
	AddressLine       string      `json:"address_line"`
	AddressRegion     string      `json:"address_region"`
	AddressCity       string      `json:"address_city"`
	CreatedAt         time.Time   `json:"created_at"`
	UpdatedAt         time.Time   `json:"updated_at"`
	CompletedAt       time.Time   `json:"completed_at"`
	TotalCount        int64       `json:"total_count"`
}

// ROW_NUMBER() OVER(ORDER BY so.id) AS order_number,
func (q *Queries) ListShopOrdersByUserIDNextPage(ctx context.Context, arg ListShopOrdersByUserIDNextPageParams) ([]ListShopOrdersByUserIDNextPageRow, error) {
	rows, err := q.db.Query(ctx, listShopOrdersByUserIDNextPage,
		arg.Limit,
		arg.UserID,
		arg.ShopOrderID,
		arg.OrderStatus,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListShopOrdersByUserIDNextPageRow{}
	for rows.Next() {
		var i ListShopOrdersByUserIDNextPageRow
		if err := rows.Scan(
			&i.Status,
			&i.ItemCount,
			&i.ID,
			&i.TrackNumber,
			&i.OrderNumber,
			&i.UserID,
			&i.PaymentTypeID,
			&i.ShippingAddressID,
			&i.OrderTotal,
			&i.ShippingMethodID,
			&i.OrderStatusID,
			&i.AddressName,
			&i.AddressTelephone,
			&i.AddressLine,
			&i.AddressRegion,
			&i.AddressCity,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShopOrdersByUserIDV2 = `-- name: ListShopOrdersByUserIDV2 :many
SELECT os.status,
(
  SELECT COUNT(*) FROM "shop_order_item" AS soi
  WHERE soi.order_id = so.id
) AS item_count
, so.id, so.track_number, so.order_number, so.user_id, so.payment_type_id, so.shipping_address_id, so.order_total, so.shipping_method_id, so.order_status_id, so.address_name, so.address_telephone, so.address_line, so.address_region, so.address_city, so.created_at, so.updated_at, so.completed_at, COUNT(*) OVER() AS total_count
FROM "shop_order" AS so
LEFT JOIN "order_status" AS os ON os.id = so.order_status_id
WHERE so.user_id = $2
AND CASE
WHEN COALESCE($3, '') != ''
THEN os.status = $3
    ELSE 1=1
END
ORDER BY so.id DESC
LIMIT $1
`

type ListShopOrdersByUserIDV2Params struct {
	Limit       int32       `json:"limit"`
	UserID      int64       `json:"user_id"`
	OrderStatus interface{} `json:"order_status"`
}

type ListShopOrdersByUserIDV2Row struct {
	Status            null.String `json:"status"`
	ItemCount         int64       `json:"item_count"`
	ID                int64       `json:"id"`
	TrackNumber       string      `json:"track_number"`
	OrderNumber       int32       `json:"order_number"`
	UserID            int64       `json:"user_id"`
	PaymentTypeID     int64       `json:"payment_type_id"`
	ShippingAddressID null.Int    `json:"shipping_address_id"`
	OrderTotal        string      `json:"order_total"`
	ShippingMethodID  int64       `json:"shipping_method_id"`
	OrderStatusID     null.Int    `json:"order_status_id"`
	AddressName       string      `json:"address_name"`
	AddressTelephone  string      `json:"address_telephone"`
	AddressLine       string      `json:"address_line"`
	AddressRegion     string      `json:"address_region"`
	AddressCity       string      `json:"address_city"`
	CreatedAt         time.Time   `json:"created_at"`
	UpdatedAt         time.Time   `json:"updated_at"`
	CompletedAt       time.Time   `json:"completed_at"`
	TotalCount        int64       `json:"total_count"`
}

// ROW_NUMBER() OVER(ORDER BY so.id) AS order_number,
func (q *Queries) ListShopOrdersByUserIDV2(ctx context.Context, arg ListShopOrdersByUserIDV2Params) ([]ListShopOrdersByUserIDV2Row, error) {
	rows, err := q.db.Query(ctx, listShopOrdersByUserIDV2, arg.Limit, arg.UserID, arg.OrderStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListShopOrdersByUserIDV2Row{}
	for rows.Next() {
		var i ListShopOrdersByUserIDV2Row
		if err := rows.Scan(
			&i.Status,
			&i.ItemCount,
			&i.ID,
			&i.TrackNumber,
			&i.OrderNumber,
			&i.UserID,
			&i.PaymentTypeID,
			&i.ShippingAddressID,
			&i.OrderTotal,
			&i.ShippingMethodID,
			&i.OrderStatusID,
			&i.AddressName,
			&i.AddressTelephone,
			&i.AddressLine,
			&i.AddressRegion,
			&i.AddressCity,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateShopOrder = `-- name: UpdateShopOrder :one
With t1 AS (
SELECT 1 AS is_admin
    FROM "admin"
    WHERE "admin".id = $9
    AND active = TRUE
    )
UPDATE "shop_order"
SET 
track_number = COALESCE($1,track_number),
user_id = COALESCE($2,user_id),
payment_type_id = COALESCE($3,payment_type_id),
shipping_address_id = COALESCE($4,shipping_address_id),
order_total = COALESCE($5,order_total),
shipping_method_id = COALESCE($6,shipping_method_id),
order_status_id = COALESCE($7,order_status_id),
updated_at = NOW(),
completed_at = CASE
    WHEN order_status_id != 2 AND $7 =2
    THEN NOW()
    ELSE completed_at
END
WHERE "shop_order".id = $8
AND (SELECT is_admin FROM t1) = 1 
RETURNING id, track_number, order_number, user_id, payment_type_id, shipping_address_id, order_total, shipping_method_id, order_status_id, address_name, address_telephone, address_line, address_region, address_city, created_at, updated_at, completed_at
`

type UpdateShopOrderParams struct {
	TrackNumber       null.String `json:"track_number"`
	UserID            null.Int    `json:"user_id"`
	PaymentTypeID     null.Int    `json:"payment_type_id"`
	ShippingAddressID null.Int    `json:"shipping_address_id"`
	OrderTotal        null.String `json:"order_total"`
	ShippingMethodID  null.Int    `json:"shipping_method_id"`
	OrderStatusID     null.Int    `json:"order_status_id"`
	ID                int64       `json:"id"`
	AdminID           int64       `json:"admin_id"`
}

func (q *Queries) UpdateShopOrder(ctx context.Context, arg UpdateShopOrderParams) (ShopOrder, error) {
	row := q.db.QueryRow(ctx, updateShopOrder,
		arg.TrackNumber,
		arg.UserID,
		arg.PaymentTypeID,
		arg.ShippingAddressID,
		arg.OrderTotal,
		arg.ShippingMethodID,
		arg.OrderStatusID,
		arg.ID,
		arg.AdminID,
	)
	var i ShopOrder
	err := row.Scan(
		&i.ID,
		&i.TrackNumber,
		&i.OrderNumber,
		&i.UserID,
		&i.PaymentTypeID,
		&i.ShippingAddressID,
		&i.OrderTotal,
		&i.ShippingMethodID,
		&i.OrderStatusID,
		&i.AddressName,
		&i.AddressTelephone,
		&i.AddressLine,
		&i.AddressRegion,
		&i.AddressCity,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}
