// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: verify_email.sql

package db

import (
	"context"
	"time"

	null "github.com/guregu/null/v5"
)

const createVerifyEmail = `-- name: CreateVerifyEmail :one
INSERT INTO "verify_email" (
    user_id,
    -- email,
    secret_code
) VALUES (
    $1, $2
) RETURNING id, user_id, secret_code, is_used, created_at, expired_at
`

type CreateVerifyEmailParams struct {
	UserID     null.Int `json:"user_id"`
	SecretCode string   `json:"secret_code"`
}

func (q *Queries) CreateVerifyEmail(ctx context.Context, arg CreateVerifyEmailParams) (VerifyEmail, error) {
	row := q.db.QueryRow(ctx, createVerifyEmail, arg.UserID, arg.SecretCode)
	var i VerifyEmail
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SecretCode,
		&i.IsUsed,
		&i.CreatedAt,
		&i.ExpiredAt,
	)
	return i, err
}

const getVerifyEmail = `-- name: GetVerifyEmail :one
SELECT id, user_id, secret_code, is_used, created_at, expired_at FROM "verify_email"
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetVerifyEmail(ctx context.Context, id int64) (VerifyEmail, error) {
	row := q.db.QueryRow(ctx, getVerifyEmail, id)
	var i VerifyEmail
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SecretCode,
		&i.IsUsed,
		&i.CreatedAt,
		&i.ExpiredAt,
	)
	return i, err
}

const getVerifyEmailByEmail = `-- name: GetVerifyEmailByEmail :one
SELECT u.email, u.username, u.is_blocked, u.is_email_verified, 
ve.id, ve.user_id, ve.secret_code, ve.is_used, ve.created_at, ve.expired_at FROM "verify_email" AS ve
JOIN "user" AS u ON u.id = ve.user_id
WHERE u.email = $1
ORDER BY ve.created_at DESC
LIMIT 1
`

type GetVerifyEmailByEmailRow struct {
	Email           string    `json:"email"`
	Username        string    `json:"username"`
	IsBlocked       bool      `json:"is_blocked"`
	IsEmailVerified bool      `json:"is_email_verified"`
	ID              int64     `json:"id"`
	UserID          null.Int  `json:"user_id"`
	SecretCode      string    `json:"secret_code"`
	IsUsed          bool      `json:"is_used"`
	CreatedAt       time.Time `json:"created_at"`
	ExpiredAt       time.Time `json:"expired_at"`
}

func (q *Queries) GetVerifyEmailByEmail(ctx context.Context, email string) (GetVerifyEmailByEmailRow, error) {
	row := q.db.QueryRow(ctx, getVerifyEmailByEmail, email)
	var i GetVerifyEmailByEmailRow
	err := row.Scan(
		&i.Email,
		&i.Username,
		&i.IsBlocked,
		&i.IsEmailVerified,
		&i.ID,
		&i.UserID,
		&i.SecretCode,
		&i.IsUsed,
		&i.CreatedAt,
		&i.ExpiredAt,
	)
	return i, err
}

const updateVerifyEmail = `-- name: UpdateVerifyEmail :one
with t1 AS (
SELECT id FROM "user" AS u
WHERE u.email = $1
AND u.is_email_verified = FALSE
),
t2 AS (
UPDATE "verify_email" 
SET is_used = TRUE
WHERE secret_code = $2
AND user_id = (SELECT id FROM t1)
AND expired_at > NOW()
RETURNING id, user_id, secret_code, is_used, created_at, expired_at
),
t3 AS (
UPDATE "user"
SET is_email_verified = TRUE
WHERE id = (SELECT user_id FROM t2)
RETURNING id, username, email, is_blocked, is_email_verified, default_payment, created_at, updated_at
),
t4 AS(
  INSERT INTO "shopping_cart" (
  user_id
) VALUES ((SELECT id FROM t1))
  RETURNING id
),
t5 AS(
  INSERT INTO "wish_list" (
    user_id
) VALUES ((SELECT id FROM t1))
  RETURNING id
)

SELECT t3.id, t3.username, t3.email, t3.is_blocked, t3.is_email_verified, t3.default_payment, t3.created_at, t3.updated_at, t4.id AS shopping_cart_id, t5.id AS wish_list_id FROM t3,t4,t5
`

type UpdateVerifyEmailParams struct {
	Email      string `json:"email"`
	SecretCode string `json:"secret_code"`
}

type UpdateVerifyEmailRow struct {
	ID              int64     `json:"id"`
	Username        string    `json:"username"`
	Email           string    `json:"email"`
	IsBlocked       bool      `json:"is_blocked"`
	IsEmailVerified bool      `json:"is_email_verified"`
	DefaultPayment  null.Int  `json:"default_payment"`
	CreatedAt       time.Time `json:"created_at"`
	UpdatedAt       time.Time `json:"updated_at"`
	ShoppingCartID  int64     `json:"shopping_cart_id"`
	WishListID      int64     `json:"wish_list_id"`
}

func (q *Queries) UpdateVerifyEmail(ctx context.Context, arg UpdateVerifyEmailParams) (UpdateVerifyEmailRow, error) {
	row := q.db.QueryRow(ctx, updateVerifyEmail, arg.Email, arg.SecretCode)
	var i UpdateVerifyEmailRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.IsBlocked,
		&i.IsEmailVerified,
		&i.DefaultPayment,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ShoppingCartID,
		&i.WishListID,
	)
	return i, err
}
